" Methods for Class process control and block context stuff"

" $Id: process.st,v 1.4 2001/07/31 14:09:48 rich Exp rich $ "

"
 $Log: process.st,v $
 Revision 1.4  2001/07/31 14:09:48  rich
 Code cleanup
 Added methods for backtracing.

 Revision 1.3  2001/01/07 16:49:24  rich
 Code cleanup.

 Revision 1.2  2000/02/01 18:10:02  rich
 Made compileable.

 Revision 1.1  1999/09/02 15:57:59  rich
 Initial revision

"

Link subclass: 'Process'
     instanceVariableNames: 'suspendedContext priority myList'
     classVariableNames: ''
     poolDictionaries: ''
     category: nil
!

Process comment: 
'I represent a unit of computation.  My instances are independantly
executable blocks that have a priority associated with them, and they
can suspend themselves and resume themselves however they wish.' !

! Process class methodsFor: 'basic'!

on: aBlock at: aPriority
    ^self new onBlock: aBlock at: aPriority
! !


! Process methodsFor: 'basic'!

terminate
    suspendedContext <- nil.
    myList notNil
        ifTrue: [myList remove: self.
                 myList <- nil].
    Processor activeProcess == self
        ifTrue: [self suspend]
! !


! Process methodsFor: 'accessing'!

priority
    ^priority
!

priority: anInteger
    priority <- anInteger
! !

! Process methodsFor: 'builtins'!

resume
    <primitive 73>
   ^self primitiveFailed
!

suspend
    <primitive 74>
   ^self primitiveFailed
! !


! Process methodsFor: 'private'!

onBlock: aBlock at: aPriority
    suspendedContext <- aBlock.
    priority <- aPriority

! !

LinkedList subclass: 'Semaphore'
           instanceVariableNames: 'signals'
           classVariableNames: ''
           poolDictionaries: ''
           category: nil
!

Semaphore comment: 
'My instances represent counting semaphores.  I provide methods for signalling
the semaphore''s availability, and methods for waiting for its availability.
I also provide some methods for implementing critical sections.  I currently
do not (because the underlying system does not) support asynchronous
signals, such as might be generated by C signals.' !

! Semaphore class methodsFor: 'instance creation'!

new
    ^self basicNew initSemaphore
!

forMutualExclusion
    | sem |
    sem <- self new.
    sem signal.
    ^sem
! !


! Semaphore methodsFor: 'mutual exclusion'!

critical: aBlock
    | result |
    self wait.
    result <- aBlock value.
    self signal.
    ^result
! !


! Semaphore methodsFor: 'private'!

initSemaphore
    signals <- 0
! !

! Semaphore methodsFor: 'builtins'!

"communication"

signal
    <primitive 71>
    ^self primitiveFailed
!

wait
    <primitive 72>
    ^self primitiveFailed
! !

Object subclass: 'ProcessorScheduler'
       instanceVariableNames: 'processLists activeProcess'
       classVariableNames: ''
       poolDictionaries: ''
       category: nil
!

ProcessorScheduler comment: 
'I provide methods that control the execution of processes.' !


! ProcessorScheduler methodsFor: 'basic'!

activeProcess
    ^activeProcess
!

terminateActive
    activeProcess terminate
!

yield
    | process priority processList |
    priority <- activeProcess priority.
    processList <- processLists at: priority.
    processList isEmpty
        ifFalse: [ processList addLast: activeProcess.
                   activeProcess suspend ]
!

activePriority
    ^self activeProcess priority
!

timingPriority
    8
!

highIOPriority
    7
!

lowIOPriority
    6
!

userInterruptPriority
    5
!
userSchedulingPriority
    4
!

userBackgroundPriority
    3
!

systemBackgroundPriority
    2

! !

! ProcessorScheduler methodsFor: 'timed invocation'!

signal: aSemaphore atMilliseconds: millis
    " signal 'aSemaphore' after 'millis' milliseconds have elapsed" 
    <primitive 98>
    ^self primitiveFailed
! !

! ProcessorScheduler methodsFor: 'creating'!

initialize: aProcess
	processLists <- Array new: 10.
	activeProcess <- aProcess
! !

! ProcessorScheduler class methodsFor: 'initialization'!

initialize
    | newsched |
    " Create correct process scheduler object"
    newsched <- ProcessorScheduler basicNew initialize: 
    			(Process on: thisContext at: 4).
    (Smalltalk at: #Processor) become: newsched.
! !

ProcessorScheduler initialize !

Object subclass: 'Delay'
       instanceVariableNames: 'resumptionTime isRelative'
       classVariableNames: 'DelayQueue DelayTimeout DelayIdle'
       poolDictionaries: ''
       category: nil
!

Delay comment: 
'I am the ultimate agent for frustration in the world.  I cause things to wait 
(typically much more than is appropriate).  When a process sends one of my insta
nces a wait message, that process goes to sleep for the interval specified 
when the instance was created.'
!

! Delay class methodsFor: 'instance creation'!

forMilliseconds: millisecondCount
    ^self new init: millisecondCount isRelative: true
!

forSeconds: secondCount
    ^self forMilliseconds: secondCount * 1000
!

untilMilliseconds: millisecondCount
    ^self new init: millisecondCount isRelative: false
! !


! Delay class methodsFor: 'general inquiries'!

millisecondClockValue
    ^" Time millisecondClockValue" self
! !


! Delay class methodsFor: 'initialization'!

initialize
    DelayQueue <- SortedCollection sortBlock:
        [ :a :b | (a key) <= (b key) ].
    DelayIdle <- Semaphore forMutualExclusion.
    DelayTimeout <- Semaphore new.
    self startDelayLoop
!

startDelayLoop
    [ [ true ] whileTrue: 
          [ DelayTimeout wait.
            DelayIdle critical: 
                [ DelayQueue removeFirst value signal.
                  DelayQueue isEmpty
                      ifFalse: [ Processor signal: DelayTimeout
                                           atMilliseconds: 
                                               (DelayQueue first key) 
                                     - self millisecondClockValue ]
                      ]
                ]
          ] forkAt: Processor timingPriority
! !

! Delay methodsFor: 'accessing'!

resumptionTime
    isRelative
        ifTrue: [ ^Delay millisecondClockValue + resumptionTime ] 
        ifFalse: [ ^resumptionTime ] 
! !

! Delay methodsFor: 'process delay'!

wait
    | elt sem |
    DelayQueue isNil
        ifTrue: [ Delay initialize ].
    sem <- Semaphore new.
    elt <- Association key: self resumptionTime
                      value: sem.
    DelayIdle critical: [ DelayQueue add: elt.
                          "If we've become the head of the list, we need to
                           alter the interrupt time"
                          DelayQueue first == elt
                              ifTrue: [ Processor signal: DelayTimeout 
                                                 atMilliseconds: 
                                                     (DelayQueue first key) -
                                                 Delay millisecondClockValue.
                                            ]
                              ].
    sem wait
! !

! Delay methodsFor: 'comparing'!

= aDelay
    ^(isRelative = aDelay isRelative)
        and: [ resumptionTime = aDelay internalResumptionTime ]
!

hash
    ^resumptionTime
! !

! Delay methodsFor: 'private'!

init: milliseconds isRelative: aBoolean
    isRelative <- aBoolean.
    resumptionTime <- milliseconds
!

isRelative
    ^isRelative
!

internalResumptionTime
    ^resumptionTime
! !

Object subclass: 'SharedQueue'
       instanceVariableNames: 'queueSem valueReady queue'
       classVariableNames: ''
       poolDictionaries: ''
       category: nil
!

SharedQueue comment: 
'My instances provide a guaranteed safe mechanism to allow for communication
between processes.  All access to the underlying data structures is
controlled with critical sections so that things proceed smoothly.' !


! SharedQueue class methodsFor: 'instance creation'!

new
    ^super new init
! !

! SharedQueue methodsFor: 'accessing'!

next
    | result |
    valueReady wait.
    queueSem critical: [ result <- queue removeFirst ].
    ^result
!

nextPut: value
    queueSem critical: [ queue addLast: value ].
    valueReady signal.
    ^value
! !


! SharedQueue methodsFor: 'private'!

init
    queue <- OrderedCollection new: 10.
    valueReady <- Semaphore new.
    queueSem <- Semaphore forMutualExclusion
! !

BlockContext comment: 
'My instances represent Smalltalk blocks, which are portions of executeable
code that have access to the environment that they were declared in, take
parameters, and can be passed around as objects to be executed by methods
outside the current class.  Block contexts are sent a message to compute
their value; this property can be used in the construction of control
flow methods.  I also provide some methods that are used in the creation
of Processes from blocks.' !


! BlockContext methodsFor: 'basic'!

whileTrue: aBlock
    [ self value ] whileTrue: [ aBlock value ].
    ^nil
!

whileFalse: aBlock
    [ self value ] whileFalse: [ aBlock value ].
    ^nil
!

whileTrue
    ^[ self value ] whileTrue: []
!

whileFalse
    ^[ self value ] whileFalse: []
! !

! BlockContext methodsFor: 'accessing'!

parentContext
    ^caller
!

backtraceString
    ^'#[] in ', home methodClass printString,
                     '>>#', home selector printString
!

caller
    ^ caller
!

ip
    ^ ip
!

sp
    ^ sp
!

argcount
    ^ argcount
!

initialIP
    ^ iip
!

selector
    ^ home selector
!

home
    ^ home
! !

! BlockContext methodsFor: 'multiple process'!

fork
    self newProcess resume
!

newProcess
    | block |
    block <- [ self value.
              Processor terminateActive ].
    block initBlock.          
    ^Process on: block at: Processor activePriority
!

newProcessWith: anArray
    | block |
    block <- [ self valueWithArguments: anArray.
              Processor terminateActive ].
    block initBlock.          
    ^Process on: block at: Processor activePriority
! !

! BlockContext methodsFor: 'scheduling'!

forkAt: priority
    (self newProcess priority: priority) resume
! !

! BlockContext methodsFor: 'private'!

initBlock 
    ip <- iip.
    sp <- 0.
    caller <- nil
! !

! BlockContext methodsFor: 'Evaluation'!

value
	" Evaluates the block"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject
	" Evaluates the block with a given value"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject value: thirdObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject value: thirdObject value: fourthObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject value: thirdObject value: fourthObject
	value: fifthObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

valueWithArguments: anArray
	"Sends the reciever the selector aSymbol"
	<primitive 66>
	^ self primitiveFailed
! !

MethodContext comment: 
'My instances represent an actively executing method.  They record various
bits of information about the execution environment, and contain the
execution stack.' !

! MethodContext methodsFor: 'accessing' !

parentContext
    ^sender
!

backtraceString
    | aString methClass aSelector |
    aString <- '#', receiver class name.
    aSelector <- self selector.
    methClass <- receiver class whichClassIncludesSelector: aSelector.
    (methClass notNil and: [ receiver class ~= methClass]) ifTrue: [
	aString <- aString,  '(', (methClass name), ')' ].
    aString <- aString, '>>'.
    (aSelector isKindOf: Symbol)
        ifTrue: [ aString <- aString, '#' ].
    aString <- aString, aSelector printString.
    ^aString
!

sender
    ^ sender
!

ip
    ^ ip
!

sp
    ^ sp
!

method
    ^ method
!

selector
    | class meth |
    class <- receiver class.
    [ class isNil ] whileFalse: [
	class selectors do: [ :key |
	    (class compiledMethodAt: key) == method ifTrue: [ ^ key ].].
	class <- class superclass
    ].
    ^ #UnknownSelector
!

receiver
    ^ receiver
! !

