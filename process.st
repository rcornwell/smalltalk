" Methods for Class process control and block context stuff"

" $Id: process.st,v 1.6 2001/08/18 16:17:02 rich Exp rich $ "

"
 $Log: process.st,v $
 Revision 1.6  2001/08/18 16:17:02  rich
 Changed classes and methods to correct categories.
 Fixed bugs in process management.

 Revision 1.5  2001/08/01 16:42:31  rich
 Enabled process scheduling.
 Corrected backtraceString and selector methods.

 Revision 1.4  2001/07/31 14:09:48  rich
 Code cleanup
 Added methods for backtracing.

 Revision 1.3  2001/01/07 16:49:24  rich
 Code cleanup.

 Revision 1.2  2000/02/01 18:10:02  rich
 Made compileable.

 Revision 1.1  1999/09/02 15:57:59  rich
 Initial revision

"

Link subclass: 'Process'
     instanceVariableNames: 'suspendedContext priority'
     classVariableNames: ''
     poolDictionaries: ''
     category: 'Process-Mangment'
!

Process comment: 
'I represent a unit of computation.  My instances are independantly
executable blocks that have a priority associated with them, and they
can suspend themselves and resume themselves however they wish.' !

! Process class methodsFor: 'basic' !

on: aBlock at: aPriority
    ^self new onBlock: aBlock at: aPriority
! !

! Process methodsFor: 'basic' !

terminate
    suspendedContext <- nil.
    Processor activeProcess == self
        ifTrue: [self suspend]
! !

! Process methodsFor: 'accessing'!

priority
    ^priority
!

priority: anInteger
    priority <- anInteger
! !

! Process methodsFor: 'builtins'!

resume
    <primitive 73>
   ^self primitiveFailed
!

suspend
    <primitive 74>
   ^self primitiveFailed
! !

! Process methodsFor: 'private'!

onBlock: aBlock at: aPriority
    suspendedContext <- aBlock.
    priority <- aPriority

! !

LinkedList subclass: 'Semaphore'
           instanceVariableNames: 'signals'
           classVariableNames: ''
           poolDictionaries: ''
           category: 'Process-Mangment'
!

Semaphore comment: 
'My instances represent counting semaphores.  I provide methods for signalling
the semaphore''s availability, and methods for waiting for its availability.
I also provide some methods for implementing critical sections.  I currently
do not (because the underlying system does not) support asynchronous
signals, such as might be generated by C signals.' !

! Semaphore class methodsFor: 'instance creation'!

new
    ^self basicNew initSemaphore
!

forMutualExclusion
    | sem |
    sem <- self new.
    sem signal.
    ^sem
! !

! Semaphore methodsFor: 'mutual exclusion'!

critical: aBlock
    | result |
    self wait.
    result <- aBlock value.
    self signal.
    ^result
! !

! Semaphore methodsFor: 'private'!

initSemaphore
    signals <- 0
! !

! Semaphore methodsFor: 'builtins'!

"communication"

signal
    <primitive 71>
    ^self primitiveFailed
!

wait
    <primitive 72>
    ^self primitiveFailed
! !

Object variableSubclass: 'BlockContext'
     instanceVariableNames: 'caller ip sp home iip unused argcount'
     classVariableNames: ''
     poolDictionaries: ''
     category: 'System-Execution' !

BlockContext comment: 
'My instances represent Smalltalk blocks, which are portions of executeable
code that have access to the environment that they were declared in, take
parameters, and can be passed around as objects to be executed by methods
outside the current class.  Block contexts are sent a message to compute
their value; this property can be used in the construction of control
flow methods.  I also provide some methods that are used in the creation
of Processes from blocks.' !


! BlockContext methodsFor: 'basic'!

whileTrue: aBlock
    [ self value ] whileTrue: [ aBlock value ].
    ^nil
!

whileFalse: aBlock
    [ self value ] whileFalse: [ aBlock value ].
    ^nil
!

whileTrue
    ^[ self value ] whileTrue: []
!

whileFalse
    ^[ self value ] whileFalse: []
! !

! BlockContext methodsFor: 'accessing'!

parentContext
    ^caller
!

backtraceString
    ^'#[] in ', home methodClass printString,
                     '>>#', home selector printString
!

caller
    ^ caller
!

ip
    ^ ip
!

sp
    ^ sp
!

argcount
    ^ argcount
!

initialIP
    ^ iip
!

selector
    ^ home selector
!

home
    ^ home
! !

! BlockContext methodsFor: 'multiple process'!

fork
    self newProcess resume
!

newProcess
    | block |
    block <- [ self value.
              Processor terminateActive ].
    block initBlock.          
    ^Process on: block at: Processor activePriority
!

newProcessWith: anArray
    | block |
    block <- [ self valueWithArguments: anArray.
              Processor terminateActive ].
    block initBlock.          
    ^Process on: block at: Processor activePriority
! !

! BlockContext methodsFor: 'scheduling'!

forkAt: priority
    (self newProcess priority: priority) resume
! !

! BlockContext methodsFor: 'private'!

initBlock 
    ip <- iip.
    caller <- nil
! !

! BlockContext methodsFor: 'Evaluation'!

value
	" Evaluates the block"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject
	" Evaluates the block with a given value"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject value: thirdObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject value: thirdObject value: fourthObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

value: anObject value: secondObject value: thirdObject value: fourthObject
	value: fifthObject
	" Evaluates the block with the given values"
	<primitive 65>
	^ self primitiveFailed
!

valueWithArguments: anArray
	"Sends the reciever the selector aSymbol"
	<primitive 66>
	^ self primitiveFailed
! !

Object variableSubclass: 'MethodContext'
     instanceVariableNames: 'sender ip sp method unused receiver argcount'
     classVariableNames: ''
     poolDictionaries: ''
     category: 'System-Execution' !

MethodContext comment: 
'My instances represent an actively executing method.  They record various
bits of information about the execution environment, and contain the
execution stack.' !

! MethodContext methodsFor: 'accessing' !

parentContext
    ^sender
!

backtraceString
    | aString methClass aSelector |
    aString <- '#', receiver class name.
    aSelector <- self selector.
    methClass <- receiver class whichClassIncludesSelector: aSelector.
    (methClass notNil and: [ receiver class ~= methClass]) ifTrue: [
	aString <- aString,  '(', (methClass name), ')' ].
    aString <- aString, '>>'.
    (aSelector isKindOf: Symbol)
        ifTrue: [ aString <- aString, '#' ].
    aString <- aString, aSelector printString.
    ^aString
!

sender
    ^ sender
!

ip
    ^ ip
!

sp
    ^ sp
!

method
    ^ method
!

selector
    | class meth |
    class <- receiver class.
    [ class isNil ] whileFalse: [
	class selectors do: [ :key |
	    (class compiledMethodAt: key) == method ifTrue: [ ^ key ].].
	class <- class superclass
    ].
    ^ #UnknownSelector
!

receiver
    ^ receiver
! !

Object subclass: 'ProcessorScheduler'
       instanceVariableNames: 'processLists activeProcess'
       classVariableNames: ''
       poolDictionaries: ''
       category: 'Process-Mangment'
!

ProcessorScheduler comment: 
'I provide methods that control the execution of processes.' !


! ProcessorScheduler methodsFor: 'basic'!

activeProcess
    ^activeProcess
!

terminateActive
    activeProcess terminate
!

yield
    | process priority processList |
    priority <- activeProcess priority.
    processList <- processLists at: priority.
    processList isEmpty
        ifFalse: [ processList addLast: activeProcess.
                   activeProcess suspend ]
!

activePriority
    ^self activeProcess priority
!

timingPriority
    8
!

highIOPriority
    7
!

lowIOPriority
    6
!

userInterruptPriority
    5
!

userSchedulingPriority
    4
!

userBackgroundPriority
    3
!

systemBackgroundPriority
    2

! !

! ProcessorScheduler methodsFor: 'idle task' !

idlewait
	" Go to sleep until something interesting happens "
	<primitive 140>
!

idletask
	" We need second send so checkProcessSwitch gets run "
	^ self idlewait
!

idleproc
   | block |
   " Return a Process to call idle task "
   block <- [ [ true ] whileTrue: [  self idletask ] ].
   ^ block forkAt: 1
! !

! ProcessorScheduler methodsFor: 'creating'!

initialize: aProcess
	| array |
	array <- Array new: 10.
	1 to: 10 do: [ :i | array at: i put: (LinkedList new) ].
	processLists <- array.
	activeProcess <- aProcess
! !

! ProcessorScheduler class methodsFor: 'initialization'!

initialize
    | newsched |
    " Create correct process scheduler object"
    newsched <- ProcessorScheduler basicNew initialize: 
    			(Process on: thisContext at: 4).
    (Smalltalk at: #Processor) become: newsched.
    " Install the idle process "
    (Smalltalk at: #Processor) idleproc.
! !

ProcessorScheduler initialize !

Object subclass: 'SharedQueue'
       instanceVariableNames: 'queueSem valueReady queue'
       classVariableNames: ''
       poolDictionaries: ''
       category: 'Process-Mangment'
!

SharedQueue comment: 
'My instances provide a guaranteed safe mechanism to allow for communication
between processes.  All access to the underlying data structures is
controlled with critical sections so that things proceed smoothly.' !


! SharedQueue class methodsFor: 'instance creation'!

new
    ^super new init
! !

! SharedQueue methodsFor: 'accessing'!

next
    | result |
    valueReady wait.
    queueSem critical: [ result <- queue removeFirst ].
    ^result
!

nextPut: value
    queueSem critical: [ queue addLast: value ].
    valueReady signal.
    ^value
! !


! SharedQueue methodsFor: 'private'!

init
    queue <- OrderedCollection new: 10.
    valueReady <- Semaphore new.
    queueSem <- Semaphore forMutualExclusion
! !


Link subclass: 'DelayNode'
       instanceVariableNames: 'timeleft sema'
       classVariableNames: ''
       poolDictionaries: ''
       category: 'Process-Mangment'
!

DelayNode comment:
'I am a private class used to manage the list of semaphores waiting to be
woke up.' !

! DelayNode class methodsFor: 'instance creation' !

after: aTime signal: aSemaphore
   ^ self new after: aTime signal: aSemaphore
! !

! DelayNode methodsFor: 'accessing' !

timeleft
	^ timeleft
!

signal
	sema signal.
! !

! DelayNode methodsFor: 'modifying' !

after: aTime signal: aSemaphore
	timeleft <- aTime.
	sema <- aSemaphore.
	^ self
!

delta: aTime
	timeleft <- timeleft - aTime
!

tick
	timeleft <- timeleft - 1.
	^ timeleft <= 0
! !

! DelayNode methodsFor: 'testing' !

timepast
	^ timeleft <= 0

! !

Object subclass: 'Delay'
       instanceVariableNames: 'resumptionTime isRelative'
       classVariableNames: 'DelayQueue DelayTimeout DelayIdle'
       poolDictionaries: ''
       category: 'Process-Mangment'
!

Delay comment: 
'I am the ultimate agent for frustration in the world.  I cause things to wait 
(typically much more than is appropriate).  When a process sends one of my insta
nces a wait message, that process goes to sleep for the interval specified 
when the instance was created.'
!

! Delay class methodsFor: 'instance creation'!

forMilliseconds: millisecondCount
    ^self new init: millisecondCount isRelative: true
!

forSeconds: secondCount
    ^self forMilliseconds: secondCount * 1000
!

untilMilliseconds: millisecondCount
    ^self new init: millisecondCount isRelative: false
! !


! Delay class methodsFor: 'general inquiries'!

millisecondClockValue
    ^ Time millisecondClockValue 
! !


! Delay class methodsFor: 'initialization'!

initialize
    DelayQueue <- LinkedList new.
    DelayIdle <- Semaphore forMutualExclusion.
    DelayTimeout <- Semaphore new.
    self signalAtTick: DelayTimeout.
    self startDelayLoop
!

startDelayLoop
    | next |
    [ [ true ] whileTrue: 
          [ DelayTimeout wait.
            DelayIdle critical: 
                [ DelayQueue isEmpty
                      ifFalse: [
			    next <- DelayQueue at: 1.
			    next tick ifTrue: [
				[ DelayQueue isEmpty not and: [
					(DelayQueue at: 1) timepast]]
					whileTrue: [
						DelayQueue removeFirst signal.
				]
			    ]
                      ]
                ]
	  ]
   ] forkAt: Processor timingPriority
!

signalAtTick: aSemaphore
    " signal 'aSemaphore' every millisecond. "
    <primitive 98>
    ^self primitiveFailed
! !

! Delay methodsFor: 'accessing'!

resumptionTime
    isRelative
        ifTrue: [ ^Delay millisecondClockValue + resumptionTime ] 
        ifFalse: [ ^resumptionTime ] 
! !

! Delay methodsFor: 'process delay'!

wait
    | sem index last next firetime elt |
    DelayQueue isNil
        ifTrue: [ Delay initialize ].
    sem <- Semaphore new.
    firetime <- self resumptionTime.
    DelayIdle critical: [
	index <- 1.
	last <- DelayQueue size.
	[ firetime >= 0 and: [index < last] ] whileTrue: [
		next <- DelayQueue at: index.
		(firetime <= next timeleft)
		    ifTrue: [
			next delta: firetime.
			DelayQueue at: index
		          insertObject: (DelayNode after: firetime signal: sem).
			firetime <- -1  ]
		    ifFalse: [ firetime <- firetime - (next timeleft) ].
		index <- index + 1.
	].
	firetime >= 0 ifTrue: [
		DelayQueue addLast: (DelayNode after: firetime signal: sem)
	]
    ].
    sem wait
! !

! Delay methodsFor: 'comparing'!

= aDelay
    ^(isRelative = aDelay isRelative)
        and: [ resumptionTime = aDelay internalResumptionTime ]
!

hash
    ^resumptionTime
! !

! Delay methodsFor: 'private'!

init: milliseconds isRelative: aBoolean
    isRelative <- aBoolean.
    resumptionTime <- milliseconds
!

isRelative
    ^isRelative
!

internalResumptionTime
    ^resumptionTime
! !

Delay initialize !


