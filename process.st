" Methods for Class process control and block context stuff"

" $Id: $ "

"
 $Log: $
"
Link subclass: 'Process'
     instanceVariableNames: 'suspendedContext priority myList'
     classVariableNames: ''
     poolDictionaries: ''
     category: nil
!

Process comment: 
'I represent a unit of computation.  My instances are independantly
executable blocks that have a priority associated with them, and they
can suspend themselves and resume themselves however they wish.' !

!Process class methodsFor: 'basic'!

on: aBlock at: aPriority
    ^self new onBlock: aBlock at: aPriority
! !


!Process methodsFor: 'basic'!

terminate
    | processList priority process |
    suspendedContext <- nil.
    myList notNil
        ifTrue: [myList remove: self.
                 myList <- nil].
    Processor activeProcess == self
        ifTrue: [self suspend]
! !


!Process methodsFor: 'accessing'!

priority
    ^priority
!

priority: anInteger
    priority <- anInteger
! !

!Process methodsFor: 'builtins'!

resume
    <primitive: 73>
   ^self primitiveFailed
!

suspend
    <primitive: 74>
   ^self primitiveFailed
! !


!Process methodsFor: 'private'!

onBlock: aBlock at: aPriority
    suspendedContext <- aBlock.
    priority <- aPriority

! !


LinkedList subclass: 'Semaphore'
           instanceVariableNames: 'signals'
           classVariableNames: ''
           poolDictionaries: ''
           category: nil
!

Semaphore comment: 
'My instances represent counting semaphores.  I provide methods for signalling
the semaphore''s availability, and methods for waiting for its availability.
I also provide some methods for implementing critical sections.  I currently
do not (because the underlying system does not) support asynchronous
signals, such as might be generated by C signals.' !

!Semaphore class methodsFor: 'instance creation'!

new
    ^self basicNew initSemaphore
!

forMutualExclusion
    | sem |
    sem <- self new.
    sem signal.
    ^sem
! !


!Semaphore methodsFor: 'mutual exclusion'!

critical: aBlock
    | result |
    self wait.
    result <- aBlock value.
    self signal.
    ^result
! !


!Semaphore methodsFor: 'private'!

initSemaphore
    signals <- 0
! !

!Semaphore methodsFor: 'builtins'!

"communication"

signal
    <primitive: 71>
    ^self primitiveFailed
!

wait
    <primitive: 72>
    ^self primitiveFailed
! !

Object subclass: 'ProcessorScheduler'
       instanceVariableNames: 'processLists activeProcess'
       classVariableNames: ''
       poolDictionaries: ''
       category: nil
!

ProcessorScheduler comment: 
'I provide methods that control the execution of processes.' !

" Create correct process scheduler object"
(Smalltalk at: #Processor) become: (ProcessScheduler basicNew). !

!ProcessorScheduler methodsFor: 'basic'!

activeProcess
    ^activeProcess
!

terminateActive
    activeProcess terminate
!

yield
    | process priority processList |
    priority <- activeProcess priority.
    processList <- processLists at: priority.
    processList isEmpty
        ifFalse: [ processList addLast: activeProcess.
                   activeProcess suspend ]
!

activePriority
    ^self activeProcess priority
!

timingPriority
    8
!

highIOPriority
    7
!

lowIOPriority
    6
!

userInterruptPriority
    5
!
userSchedulingPriority
    4
!

userBackgroundPriority
    3
!

systemBackgroundPriority
    2

! !

!ProcessorScheduler methodsFor: 'timed invocation'!

signal: aSemaphore atMilliseconds: millis
    " signal 'aSemaphore' after 'millis' milliseconds have elapsed" 
    <primitive: 100>
    ^self primitiveFailed
!

signal: aSemaphore onInterrupt: anIntegerSignalNumber
    <primitive: 152>
    ^self primitiveFailed
! !

Object subclass: 'Delay'
       instanceVariableNames: 'resumptionTime isRelative'
       classVariableNames: 'DelayQueue DelayTimeout DelayIdle'
       poolDictionaries: ''
       category: nil
!

Delay comment: 
'I am the ultimate agent for frustration in the world.  I cause things to wait 
(typically much more than is appropriate).  When a process sends one of my insta
nces a wait message, that process goes to sleep for the interval specified 
when the instance was created.'
!
           

!Delay class methodsFor: 'instance creation'!

forMilliseconds: millisecondCount
    ^self new init: millisecondCount isRelative: true
!

forSeconds: secondCount
    ^self forMilliseconds: secondCount * 1000
!

untilMilliseconds: millisecondCount
    ^self new init: millisecondCount isRelative: false
! !


!Delay class methodsFor: 'general inquiries'!

millisecondClockValue
    ^Time millisecondClockValue
! !


!Delay class methodsFor: 'initialization'!

initialize
    DelayQueue <- SortedCollection sortBlock:
        [ :a :b | (a key) <= (b key) ].
    DelayIdle <- Semaphore forMutualExclusion.
    DelayTimeout <- Semaphore new.
    self startDelayLoop
!

startDelayLoop
    [ [ true ] whileTrue: 
          [ DelayTimeout wait.
            DelayIdle critical: 
                [ DelayQueue removeFirst value signal.
                  DelayQueue isEmpty
                      ifFalse: [ Processor signal: DelayTimeout
                                           atMilliseconds: 
                                               (DelayQueue first key) 
                                     - self millisecondClockValue ]
                      ]
                ]
          ] forkAt: Processor timingPriority
! !

!Delay methodsFor: 'accessing'!

resumptionTime
    isRelative
        ifTrue: [ ^Delay millisecondClockValue + resumptionTime ] 
        ifFalse: [ ^resumptionTime ] 
! !

!Delay methodsFor: 'process delay'!

wait
    | elt sem |
    DelayQueue isNil
        ifTrue: [ Delay initialize ].
    sem <- Semaphore new.
    elt <- Association key: self resumptionTime
                      value: sem.
    DelayIdle critical: [ DelayQueue add: elt.
                          "If we've become the head of the list, we need to
                           alter the interrupt time"
                          DelayQueue first == elt
                              ifTrue: [ Processor signal: DelayTimeout 
                                                 atMilliseconds: 
                                                     (DelayQueue first key) -
                                                 Delay millisecondClockValue.
                                            ]
                              ].
    sem wait
! !
!Delay methodsFor: 'comparing'!

= aDelay
    ^(isRelative = aDelay isRelative)
        and: [ resumptionTime = aDelay internalResumptionTime ]
!

hash
    ^resumptionTime
! !

!Delay methodsFor: 'private'!

init: milliseconds isRelative: aBoolean
    isRelative <- aBoolean.
    resumptionTime <- milliseconds
!

isRelative
    ^isRelative
!

internalResumptionTime
    ^resumptionTime
! !

Object subclass: 'SharedQueue'
       instanceVariableNames: 'queueSem valueReady queue'
       classVariableNames: ''
       poolDictionaries: ''
       category: nil
!

SharedQueue comment: 
'My instances provide a guaranteed safe mechanism to allow for communication
between processes.  All access to the underlying data structures is
controlled with critical sections so that things proceed smoothly.' !


!SharedQueue class methodsFor: 'instance creation'!

new
    ^super new init
! !

!SharedQueue methodsFor: 'accessing'!

next
    | result |
    valueReady wait.
    queueSem critical: [ result <- queue removeFirst ].
    ^result
!

nextPut: value
    queueSem critical: [ queue addLast: value ].
    valueReady signal.
    ^value
! !


!SharedQueue methodsFor: 'private'!

init
    queue <- OrderedCollection new: 10.
    valueReady <- Semaphore new.
    queueSem <- Semaphore forMutualExclusion
! !

BlockContext comment: 
'My instances represent Smalltalk blocks, which are portions of executeable
code that have access to the environment that they were declared in, take
parameters, and can be passed around as objects to be executed by methods
outside the current class.  Block contexts are sent a message to compute
their value; this property can be used in the construction of control
flow methods.  I also provide some methods that are used in the creation
of Processes from blocks.' !


!BlockContext methodsFor: 'basic'!

whileTrue: aBlock
    [ self value ] whileTrue: [ aBlock value ].
    ^nil
!

whileFalse: aBlock
    [ self value ] whileFalse: [ aBlock value ].
    ^nil
!

whileTrue
    ^[ self value ] whileTrue: []
!

whileFalse
    ^[ self value ] whileFalse: []
! !


!BlockContext methodsFor: 'multiple process'!

fork
    self newProcess resume
!

newProcess
    | block |
    block <- [ self value.
              Processor terminateActive ].
    block initBlock.          
    ^Process on: block at: Processor activePriority
!

newProcessWith: anArray
    | block |
    block <- [ self valueWithArguments: anArray.
              Processor terminateActive ].
    block initBlock.          
    ^Process on: block at: Processor activePriority
! !

!BlockContext methodsFor: 'scheduling'!

forkAt: priority
    (self newProcess priority: priority) resume
! !

!BlockContext methodsFor: 'private'!

initBlock 
    ip <- initialIP.
    sp <- 0.
    caller <- nil
! !

MethodContext comment: 
'My instances represent an actively executing method.  They record various
bits of information about the execution environment, and contain the
execution stack.' !
